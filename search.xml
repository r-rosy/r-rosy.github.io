<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>middleware的使用</title>
    <url>/2022/01/18/middleware/</url>
    <content><![CDATA[<p>当我们使用gin框架时，可以在中间件中进行跨域设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1 // 中间件</span><br><span class="line"> 2 func middleware() gin.HandlerFunc &#123;</span><br><span class="line"> 3     return func(c *gin.Context) &#123;</span><br><span class="line"> 4         t := time.Now()</span><br><span class="line"> 5         c.Set(&quot;example&quot;, &quot;123456&quot;)</span><br><span class="line"> 6         // c.Next()后就执行真实的路由函数，路由执行完成之后接着走time.Since(t)</span><br><span class="line"> 7         c.Next()</span><br><span class="line"> 8 </span><br><span class="line"> 9         // 从time.Now()到目前为止过了多长时间</span><br><span class="line">10         latency := time.Since(t)</span><br><span class="line">11         log.Print(&quot;--&quot;, latency)</span><br><span class="line">12 </span><br><span class="line">13         // gin设置响应头，设置跨域</span><br><span class="line">14         c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)</span><br><span class="line">15         c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE&quot;)</span><br><span class="line">16         c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Action, Module, X-PINGOTHER, Content-Type, Content-Disposition&quot;)</span><br><span class="line">17 </span><br><span class="line">18         //设置中间件的响应头，路由的响应头可以在路由返回中设置，参考/ping</span><br><span class="line">19         // c.Writer.WriteHeader(http.StatusMovedPermanently)</span><br><span class="line">20         status := c.Writer.Status()</span><br><span class="line">21         log.Println(&quot;==&quot;, status)</span><br><span class="line">22     &#125;</span><br><span class="line">23 &#125;</span><br><span class="line">24 </span><br><span class="line">25 func middle(c *gin.Context) &#123;</span><br><span class="line">26     example := c.MustGet(&quot;example&quot;).(string)</span><br><span class="line">27     log.Println(example)</span><br><span class="line">28 &#125;</span><br><span class="line">29 </span><br><span class="line">30 func main() &#123;</span><br><span class="line">31     r := gin.Default()</span><br><span class="line">32 </span><br><span class="line">33     //中间件，只有在中间件之后注册的路由才会走中间件</span><br><span class="line">34     r.Use(middleware())</span><br><span class="line">35     //http://localhost:8081/middle</span><br><span class="line">36     r.GET(&quot;/middle&quot;, middle)</span><br><span class="line">37 </span><br><span class="line">38     r.Run(&quot;:8081&quot;)</span><br><span class="line">39 &#125;</span><br></pre></td></tr></table></figure>

<p>每次执行路由函数middle()之前都会执行middleware()函数，在执行到middleware函数中c.Next()时，会执行真正的路由函数middle()，路由函数执行完成之后会继续执行middleware()中c.Next()函数后面的代码。</p>
<p>另一回答—</p>
<p>gin框架中间件 c.Next() c.Abort() c.Set() c.Get 跨中间件取值 gin中间件中使用goroutine_可控的事情要谨慎，不可控的事情要乐观。-CSDN博客</p>
<p>深入Gin框架内幕(一) - 知乎—参考该方法中的最后一部分内容（模拟请求）</p>
<p>（1）示例1：</p>
<p>package main</p>
<p>import (<br>    “fmt”<br>    “github.com/gin-gonic/gin”<br>    “net/http”<br>    “time”<br>)</p>
<p>// HandlerFunc<br>func indexHandler(c *gin.Context) {<br>    fmt.Println(“index”)<br>    c.JSON(http.StatusOK, gin.H{<br>        “msg”: “index”,<br>    })<br>}</p>
<p>// 定义一个中间件<br>func m1(c *gin.Context) {<br>    fmt.Println(“m1 in …”)<br>    // 计时<br>    start := time.Now()<br>    c.Next() // 调用后续的处理函数</p>
<pre><code>//c.Abort()      // 阻止调用后续的处理函数
cost := time.Since(start)
fmt.Printf(&quot;cost:%v\n&quot;, cost)
fmt.Printf(&quot;m1 out ...&quot;)
</code></pre>
<p>}</p>
<p>func m2(c *gin.Context) {<br>    fmt.Println(“m2 in …”)<br>    c.Next() // 调用后续的处理函数<br>    //c.Abort()   //阻止调用后续的处理函数，也就是m2它自己走完就行<br>    //return<br>    fmt.Println(“m2 out …”)<br>}</p>
<p>func main() {<br>    r := gin.Default()</p>
<pre><code>// 点GET查看源码发现
// GET(relativepath string,handlers ...HandlerFunc) IRoutes 另外,...表示可传多个HandlerFunc类型的函数
 
//r.GET(&quot;/index&quot;, m1, indexHandler)
//r.GET(&quot;/shop&quot;, m1, func(c *gin.Context) &#123;
//    c.JSON(http.StatusOK, gin.H&#123;
//        &quot;msg&quot;: &quot;shop&quot;,
//    &#125;)
//&#125;)
//r.GET(&quot;/user&quot;, m1, func(c *gin.Context) &#123;
//    c.JSON(http.StatusOK, gin.H&#123;
//        &quot;msg&quot;: &quot;user&quot;,
//    &#125;)
//&#125;)
 
//点开use查看源码发现 Use(middleware ...HandlerFunc) IRoutes
r.Use(m1, m2) // 全局注册中间件函数m1 m2
 
/*访问/index
执行indexHandler之前去执行注册的中间件,总的执行打印顺序是:m1 in -&gt; m2 in -&gt; index -&gt; m2 out -&gt; m1 out
*/
r.GET(&quot;/index&quot;, indexHandler)
r.GET(&quot;/shop&quot;, func(c *gin.Context) &#123;
    c.JSON(http.StatusOK, gin.H&#123;
        &quot;msg&quot;: &quot;shop&quot;,
    &#125;)
&#125;)
r.GET(&quot;/user&quot;, func(c *gin.Context) &#123;
    c.JSON(http.StatusOK, gin.H&#123;
        &quot;msg&quot;: &quot;user&quot;,
    &#125;)
&#125;)
 
r.Run(&quot;:9090&quot;)
</code></pre>
<p>}<br>（2）示例2：</p>
<p>package main</p>
<p>import (<br>    “fmt”<br>    “github.com/gin-gonic/gin”<br>    “net/http”<br>    “time”<br>)</p>
<p>// HandlerFunc<br>func indexHandler(c *gin.Context) {<br>    fmt.Println(“index”)</p>
<pre><code>name, ok := c.Get(&quot;name&quot;) //取值实现了跨中间件取值
if !ok &#123;
    name = &quot;default user&quot;
&#125;
//fmt.Println(name)
 
c.JSON(http.StatusOK, gin.H&#123;
    &quot;msg&quot;: name,
&#125;)
</code></pre>
<p>}</p>
<p>// 定义一个中间件<br>func m1(c *gin.Context) {<br>    fmt.Println(“m1 in…”)<br>    // 计时<br>    start := time.Now()</p>
<pre><code>// gin中间件中使用goroutine
// 当在中间件或handler中启动新的goroutine时,不能使用原始的上下文(c *gin.Context),必须使用其只读副本(c.Copy())
//go otherFunc(c.Copy())     // 在otherFunc中只能使用c的拷贝
 
c.Next() // 调用后续的处理函数
 
//c.Abort() // 阻止调用后续的处理函数
cost := time.Since(start)
fmt.Printf(&quot;cost:%v\n&quot;, cost)
fmt.Printf(&quot;m1 out...&quot;)
</code></pre>
<p>}</p>
<p>func m2(c *gin.Context) {<br>    fmt.Println(“m2 in…”)</p>
<pre><code>c.Set(&quot;name&quot;, &quot;tony&quot;) // 可以在请求上下文里面设置一些值,然后其他地方取值
 
c.Next() //调用后续的处理函数
//c.Abort() // 阻止调用后续的处理函数,也就是m2它自己走完就行
//return
fmt.Println(&quot;m2 out...&quot;)
</code></pre>
<p>}</p>
<p>// 自定义认证中间件,通过这种方式实现一些灵活的控制<br>func authMiddleware(doCheck bool) gin.HandlerFunc {<br>    // 连接数据库<br>    // 或其他一些准备工作<br>    return func(c *gin.Context) {<br>        if doCheck {<br>            // 这里存放具体的逻辑<br>            // 是否登录的判断<br>            //if 是登录的用户 {<br>            //    c.Next()<br>            //}else {<br>            //    c.Abort()<br>            //}<br>            name, ok := c.Get(“name”) //取值实现了跨中间件取值<br>            if ok {<br>                fmt.Println(name)<br>                c.Next()<br>                fmt.Println(“authMiddleware”)<br>            }<br>        } else {<br>            c.Next()<br>        }<br>    }<br>}</p>
<p>func main() {<br>    r := gin.Default()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点开Use查看源码发现 Use(middleware ...HandlerFunc) IRoutes</span></span><br><span class="line">r.Use(m1, m2, authMiddleware(<span class="literal">true</span>)) <span class="comment">//全局注册中间件函数m1 m2 authMiddleware</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*访问/index</span></span><br><span class="line"><span class="comment">执行indexHandler之前,去执行注册的中间件,总的执行打印顺序是:m1 in -&gt; m2 in -&gt; index -&gt; m2 out -&gt; m1 out</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, indexHandler)</span><br><span class="line">r.GET(<span class="string">&quot;/shop&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;shop&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*路由组注册中间件方法1</span></span><br><span class="line"><span class="comment">routerGroup1 := r.Group(&quot;/xx&quot;, authMiddleware(true))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	routerGroup1.GET(&quot;index&quot;, func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">		c.JSON(http.StatusOK, gin.H&#123;</span></span><br><span class="line"><span class="comment">			&quot;msg&quot;: &quot;routerGroup1&quot;,</span></span><br><span class="line"><span class="comment">		&#125;)</span></span><br><span class="line"><span class="comment">	&#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//路由组注册中间件方法2</span></span><br><span class="line">routerGroup2 := r.Group(<span class="string">&quot;/xx2&quot;</span>)</span><br><span class="line">routerGroup2.Use(authMiddleware(<span class="literal">true</span>))</span><br><span class="line">&#123;</span><br><span class="line">	routerGroup2.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;routeGroup2&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line"> </span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>原文链接：<a href="https://blog.csdn.net/qq_42303254/article/details/116136055">https://blog.csdn.net/qq_42303254/article/details/116136055</a></p>
]]></content>
      <categories>
        <category>gin</category>
      </categories>
      <tags>
        <tag>middleware</tag>
        <tag>go</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>GoWeb开发中token及其使用解析</title>
    <url>/2022/01/18/token/</url>
    <content><![CDATA[<h1 id="生成解析token"><a href="#生成解析token" class="headerlink" title="生成解析token"></a>生成解析token</h1><p>如今有很多将身份验证内置到API中的方法 -JSON Web令牌只是其中之一。JSON Web令牌（JWT）作为令牌系统而不是在每次请求时都发送用户名和密码，因此比其他方法（如基本身份验证）具有固有的优势。要了解更多信息，请直接进入jwt.io上的介绍，然后再直接学习。</p>
<p>以下是JWT的实际应用示例。主要有两个部分：提供用户名和密码以获取令牌；并根据请求检查该令牌。</p>
<p>在此示例中，我们使用了两个库，即Go中的JWT实现以及将其用作中间件的方式。</p>
<p>最后，在使用此代码之前，您需要将APP_KEY常量更改为机密（理想情况下，该常量将存储在代码库外部），并改进用户名/密码检查中的内容，TokenHandler以检查不仅仅是myusername/ mypassword组合。</p>
<p>下面的代码是gin框架对jwt的封装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个字符串</span></span><br><span class="line"><span class="keyword">var</span> jwtkey = []<span class="keyword">byte</span>(<span class="string">&quot;www.topgoer.com&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Claims <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserId <span class="keyword">uint</span></span><br><span class="line">    jwt.StandardClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/set&quot;</span>, setting)</span><br><span class="line">    r.GET(<span class="string">&quot;/get&quot;</span>, getting)</span><br><span class="line">    <span class="comment">//监听端口默认为8080</span></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//颁发token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setting</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    expireTime := time.Now().Add(<span class="number">7</span> * <span class="number">24</span> * time.Hour)</span><br><span class="line">    claims := &amp;Claims&#123;</span><br><span class="line">        UserId: <span class="number">2</span>,</span><br><span class="line">        StandardClaims: jwt.StandardClaims&#123;</span><br><span class="line">            ExpiresAt: expireTime.Unix(), <span class="comment">//过期时间</span></span><br><span class="line">            IssuedAt:  time.Now().Unix(),</span><br><span class="line">            Issuer:    <span class="string">&quot;127.0.0.1&quot;</span>,  <span class="comment">// 签名颁发者</span></span><br><span class="line">            Subject:   <span class="string">&quot;user token&quot;</span>, <span class="comment">//签名主题</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">    <span class="comment">// fmt.Println(token)</span></span><br><span class="line">    tokenString, err := token.SignedString(jwtkey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    str = tokenString</span><br><span class="line">    ctx.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;token&quot;</span>: tokenString&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getting</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    tokenString := ctx.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">    <span class="comment">//vcalidate token formate</span></span><br><span class="line">    <span class="keyword">if</span> tokenString == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;code&quot;</span>: <span class="number">401</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;权限不足&quot;</span>&#125;)</span><br><span class="line">        ctx.Abort()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token, claims, err := ParseToken(tokenString)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !token.Valid &#123;</span><br><span class="line">        ctx.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;code&quot;</span>: <span class="number">401</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;权限不足&quot;</span>&#125;)</span><br><span class="line">        ctx.Abort()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="number">111</span>)</span><br><span class="line">    fmt.Println(claims.UserId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="keyword">string</span>)</span> <span class="params">(*jwt.Token, *Claims, error)</span></span> &#123;</span><br><span class="line">    Claims := &amp;Claims&#123;&#125;</span><br><span class="line">    token, err := jwt.ParseWithClaims(tokenString, Claims, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(i <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jwtkey, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> token, Claims, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
        <category>方法</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gin</tag>
        <tag>token</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>viper</title>
    <url>/2022/01/18/viper/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Swag及其使用</title>
    <url>/2022/01/18/swag/</url>
    <content><![CDATA[<p>下面以gin-swagger为例，说明swaggo的用法。</p>
<p>安装swag命令行<br>要使用swaggo，首先要下载一个swag命令行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure>

<p>在$ GOPATH / bin /下会看到多了一个swag。把$ GOPATH / bin /加到PATH后，就可以直接用swag命令行了。</p>
<p>在包含main.go的Go工程的根目录下执行swag init，swag会检索当前工程里的swag注解（类似上述Java中的注解），生成docs.go以及swagger.json/yaml。</p>
<p>获取gin专用的gin-swagger<br>里面包含了一个示例代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get -u github.com/swaggo/gin-swagger</span><br><span class="line">$ <span class="keyword">go</span> get -u github.com/swaggo/gin-swagger/swaggerFiles</span><br></pre></td></tr></table></figure>


<p>编写gin-swagger需要的注释<br>接下来就是编写注释了。注释分为两部分，一是整体应用的说明，二是具体api的说明。</p>
<p>整体应用的说明<br>在主入口main.go中增加：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span> <span class="comment">// gin-swagger middleware</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span> <span class="comment">// swagger embed files</span></span><br></pre></td></tr></table></figure>


<p>以及针对该应用程序的api说明。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><span class="string">`)</span></span><br></pre></td></tr></table></figure>

<pre><code>_ &quot;github.com/swaggo/gin-swagger/example/docs&quot;
</code></pre>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @title Swagger Example API</span></span><br><span class="line"><span class="comment">// @version 0.0.1</span></span><br><span class="line"><span class="comment">// @description  This is a sample server Petstore server.</span></span><br><span class="line"><span class="comment">// @BasePath /api/v1/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>请注意@BasePath。 ？swagger注释中说明的@BasePath，，@Router而不是gin代码中声明的路径（没那么智能）。</p>
<p>具体api的说明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// @Summary Add a new pet to the store</span></span><br><span class="line"><span class="comment">// @Description get string by ID</span></span><br><span class="line"><span class="comment">// @Accept  json</span></span><br><span class="line"><span class="comment">// @Produce  json</span></span><br><span class="line"><span class="comment">// @Param   some_id     path    int     true        &quot;Some ID&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;string&#125; string	&quot;ok&quot;</span></span><br><span class="line"><span class="comment">// @Failure 400 &#123;object&#125; web.APIError &quot;We need ID!!&quot;</span></span><br><span class="line"><span class="comment">// @Failure 404 &#123;object&#125; web.APIError &quot;Can not find ID&quot;</span></span><br><span class="line"><span class="comment">// @Router /testapi/get-string-by-int/&#123;some_id&#125; [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStringByInt</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	err := web.APIError&#123;&#125;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>说明下几个参数。</p>
<p>如果不需要参数（例如，获取所有类型的，由url就齐活了），则不需要加@Param。参数可以是int或字符串类型。这里的定义会影响swagger ui发送的请求，如果定义错了会导致发送请求的数据不对，例如对数字进行了转义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Param group body model.SwagGroupAdd true &quot;Add group&quot;</span></span><br><span class="line"><span class="comment">// @Param name path string true &quot;Group Name&quot;</span></span><br><span class="line"><span class="comment">// @Param role query int true &quot;Role ID&quot;</span></span><br></pre></td></tr></table></figure>

<p>@Success和@Failure定义了返回值，类型可以是字符串，对象，数组。按照一般的restful定义，这三个类型足够表达返回值了。</p>
<p>GET /collection：返回资源对象的列表（数组）<br>GET /collection/resource：返回单个资源对象<br>POST /collection：返回新生成的资源对象<br>PUT /collection/resource：返回完整的资源对象<br>PATCH /collection/resource：返回完整的资源对象<br>DELETE /collection/resource：返回一个空文档<br>不过有些不太标准的restful实践会在上述返回之上再包装一个代码/消息/正文，所以对swaggo来说会造成一些新的负担，因为必须为这些返回类型单独加对应的类型。这项。</p>
<p>swag初始化<br>在项目根目录里执行swag init，生成docs/docs.go；再执行go run main.go，访问<a href="http://localhost:8080/swagger/index.html%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%84%89%E5%BF%AB%E7%9A%84%E4%BD%BF%E7%94%A8swagger">http://localhost:8080/swagger/index.html，就可以愉快的使用swagger</a> ui了。</p>
<p>参考原文链接：<a href="https://blog.csdn.net/qq_34857250/article/details/105122232">https://blog.csdn.net/qq_34857250/article/details/105122232</a></p>
]]></content>
      <categories>
        <category>go</category>
        <category>框架工具</category>
      </categories>
      <tags>
        <tag>Swaggo</tag>
        <tag>Swag</tag>
      </tags>
  </entry>
</search>
